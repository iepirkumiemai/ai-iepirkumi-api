import base64
import tempfile
import zipfile
from pathlib import Path
from typing import List, Optional

from fastapi import FastAPI, UploadFile, File, Form
from fastapi.responses import JSONResponse

from PyPDF2 import PdfReader
import docx
from docx import Document

# EDOC ekstraktors – izmantojam to, ko jau izveidojām atsevišķā failā
from edoc_extractor import is_edoc, unpack_edoc, EdocError


app = FastAPI(
    title="AI Tender Analyzer – Analyze endpoint ar EDOC atbalstu",
    version="0.3.0",
)


# ======================================================
# PALĪGFUNKCIJAS DOKUMENTU EKSTRAKCIJAI
# ======================================================

def extract_pdf(path: Path) -> str:
    reader = PdfReader(str(path))
    chunks: List[str] = []
    for page in reader.pages:
        text = page.extract_text() or ""
        chunks.append(text)
    return "\n".join(chunks)


def extract_docx(path: Path) -> str:
    d = docx.Document(str(path))
    return "\n".join(p.text for p in d.paragraphs)


def extract_zip(path: Path) -> str:
    tmp_dir = Path(tempfile.mkdtemp(prefix="zip_"))
    texts: List[str] = []

    with zipfile.ZipFile(path, "r") as zf:
        zf.extractall(tmp_dir)

    for f in tmp_dir.rglob("*"):
        if not f.is_file():
            continue

        ext = f.suffix.lower()
        if ext == ".pdf":
            texts.append(extract_pdf(f))
        elif ext == ".docx":
            texts.append(extract_docx(f))
        elif ext in {".txt", ".rtf"}:
            texts.append(f.read_text(encoding="utf-8", errors="ignore"))

    if not texts:
        return "[ZIP] Arhīvā nav nolasāmu dokumentu."

    return "\n\n-----\n\n".join(texts)


def extract_edoc(path: Path) -> str:
    """Izvelk tekstu no .edoc konteinera, izmantojot edoc_extractor."""
    try:
        inner_files: List[Path] = unpack_edoc(path)
    except EdocError as e:
        return f"[EDOC ERROR] {e}"

    texts: List[str] = []
    for inner in inner_files:
        ext = inner.suffix.lower()

        if ext == ".pdf":
            texts.append(extract_pdf(inner))
        elif ext == ".docx":
            texts.append(extract_docx(inner))
        elif ext in {".txt", ".rtf"}:
            texts.append(inner.read_text(encoding="utf-8", errors="ignore"))
        else:
            texts.append(f"[NEATBALSTĪTS EDOC IETVĒRUMA TIPS: {ext}]")

    if not texts:
        return "[EDOC] Konteinerā nav nolasāmu dokumentu."

    return "\n\n-----\n\n".join(texts)


def extract_any_document(path: Path) -> str:
    """Universāls ekstraktors vienam failam."""
    path = Path(path)
    suffix = path.suffix.lower()

    if is_edoc(path) or suffix == ".edoc":
        return extract_edoc(path)

    if suffix == ".pdf":
        return extract_pdf(path)

    if suffix == ".docx":
        return extract_docx(path)

    if suffix in {".txt", ".rtf"}:
        return path.read_text(encoding="utf-8", errors="ignore")

    if suffix == ".zip":
        return extract_zip(path)

    return f"[UNSUPPORTED FILE TYPE {suffix}] – saturs jāpārbauda manuāli."


def build_docx_report(
    candidate_name: str,
    tender_text: str,
    candidate_text: str,
) -> bytes:
    """
    Uzģenerē vienkāršu DOCX atskaiti un atgriež tās baitus.
    """
    doc = Document()
    doc.add_heading(f"Tender analysis for {candidate_name}", level=1)

    doc.add_heading("1. Tender document – excerpt", level=2)
    doc.add_paragraph(tender_text[:2000] or "[no tender text extracted]")

    doc.add_heading("2. Candidate documents – excerpt", level=2)
    doc.add_paragraph(candidate_text[:2000] or "[no candidate text extracted]")

    doc.add_heading("3. Short technical note", level=2)
    doc.add_paragraph(
        "This is a technical demo report generated by the AI Tender Analyzer backend. "
        "In the production version this section will contain structured compliance analysis."
    )

    with tempfile.NamedTemporaryFile(suffix=".docx", delete=False) as tmp:
        doc.save(tmp.name)
        tmp.seek(0)
        data = tmp.read()

    return data


def build_dummy_html_table() -> str:
    """
    Vienkārša HTML tabula, lai frontends jau tagad kaut ko var rādīt.
    Vēlāk šeit ieliksim reālo salīdzināšanas rezultātu.
    """
    return """
<table border="1" cellspacing="0" cellpadding="4">
  <tr>
    <th>Criterion</th>
    <th>Status</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td>Formal compliance</td>
    <td>OK</td>
    <td>Documents were successfully read and parsed.</td>
  </tr>
  <tr>
    <td>Content comparison</td>
    <td>DEMO</td>
    <td>AI comparison logic will be implemented in the next iteration.</td>
  </tr>
</table>
""".strip()


# ======================================================
# GALVENAIS ENDPOINTS – TAS PATS URL, KO TU LIETO
# ======================================================

@app.post("/ai-tender/analyze")
async def analyze_tender(
    candidate_name: str = Form(...),
    tender_file: Optional[UploadFile] = File(None),
    candidate_archive: Optional[UploadFile] = File(None),
    tender_dropbox_path: Optional[str] = Form(None),
    candidate_dropbox_path: Optional[str] = Form(None),
):
    """
    Legacy /ai-tender/analyze endpoint, tagad ar EDOC atbalstu.
    Pieņem:
      - candidate_name
      - tender_file  (PDF/DOCX/ZIP/EDOC)
      - candidate_archive (PDF/DOCX/ZIP/EDOC)
    Dropbox ceļus pagaidām ignorē (to pieslēgsim vēlāk).
    """

    error_flags: List[str] = []
    tender_text = ""
    candidate_text = ""

    # ------------------------------
    # 1. Prasību dokuments (tender_file)
    # ------------------------------
    if tender_file is not None:
        tmp_tender_path = Path(tempfile.mkdtemp(prefix="tender_")) / tender_file.filename
        with open(tmp_tender_path, "wb") as f:
            f.write(await tender_file.read())
        tender_text = extract_any_document(tmp_tender_path)
    elif tender_dropbox_path:
        error_flags.append("tender_dropbox_not_implemented")
    else:
        error_flags.append("no_tender_file")

    # ------------------------------
    # 2. Kandidāta dokumenti (candidate_archive)
    # ------------------------------
    if candidate_archive is not None:
        tmp_cand_path = Path(tempfile.mkdtemp(prefix="candidate_")) / candidate_archive.filename
        with open(tmp_cand_path, "wb") as f:
            f.write(await candidate_archive.read())
        candidate_text = extract_any_document(tmp_cand_path)
    elif candidate_dropbox_path:
        error_flags.append("candidate_dropbox_not_implemented")
    else:
        error_flags.append("no_candidate_archive")

    # ------------------------------
    # 3. DOCX atskaites ģenerēšana
    # ------------------------------
    report_bytes = build_docx_report(candidate_name, tender_text, candidate_text)
    docx_b64 = base64.b64encode(report_bytes).decode("utf-8")

    html_table = build_dummy_html_table()

    response = {
        "candidate_name": candidate_name,
        "error_flags": error_flags,
        "tender_excerpt": tender_text[:1500],
        "candidate_excerpt": candidate_text[:1500],
        "html_table": html_table,
        "docx_base64": docx_b64,
    }

    return JSONResponse(response)


# (nav obligāti, bet ērti health-checkam)
@app.get("/health")
async def health():
    return {"status": "ok", "service": "ai-tender-analyze-edoc"}
